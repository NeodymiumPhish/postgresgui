//
//  QueryResultsComponent.swift
//  PostgresGUI
//
//  Presentational component for displaying query results.
//  Receives data and callbacks - does not access AppState directly.
//

import SwiftUI

// MARK: - Table Row Comparator

struct TableRowComparator: SortComparator, Hashable {
    let columnName: String
    var order: SortOrder = .forward

    func compare(_ lhs: TableRow, _ rhs: TableRow) -> ComparisonResult {
        let result = compareValues(lhs.values[columnName] ?? nil, rhs.values[columnName] ?? nil)
        return order == .reverse ? result.reversed : result
    }

    private func compareValues(_ lhs: String?, _ rhs: String?) -> ComparisonResult {
        switch (lhs, rhs) {
        case (nil, nil): return .orderedSame
        case (nil, _): return .orderedDescending
        case (_, nil): return .orderedAscending
        case let (v1?, v2?):
            return v1.localizedStandardCompare(v2)
        }
    }
}

private extension ComparisonResult {
    var reversed: ComparisonResult {
        switch self {
        case .orderedAscending: return .orderedDescending
        case .orderedDescending: return .orderedAscending
        case .orderedSame: return .orderedSame
        }
    }
}

// MARK: - Query Results Component

struct QueryResultsComponent: View {
    // Data
    let results: [TableRow]
    let columnNames: [String]?
    let searchText: String
    let isExecuting: Bool
    let errorMessage: String?
    let hasExecutedQuery: Bool
    let currentPage: Int
    let hasNextPage: Bool
    let tableId: String?
    
    // Bindings
    @Binding var selectedRowIDs: Set<TableRow.ID>
    
    // Callbacks
    let onPreviousPage: () -> Void
    let onNextPage: () -> Void
    var onDeleteKeyPressed: (() -> Void)?
    var onSpaceKeyPressed: (() -> Void)?
    
    // Local state for sorting
    @State private var sortOrder: [TableRowComparator] = []
    
    private var hasPreviousPage: Bool {
        currentPage > 0
    }
    
    private var showPagination: Bool {
        currentPage > 0 || hasNextPage
    }

    var body: some View {
        VStack(spacing: 0) {
            // Results or error display - greyed out during execution
            resultsContent
                .opacity(isExecuting ? 0.4 : 1.0)
                .allowsHitTesting(!isExecuting)

            // Pagination row (only show if there's more than one page)
            if showPagination {
                paginationBar
            }
        }
        .padding(.leading, 4)
        .onChange(of: tableId) { oldValue, newValue in
            // Reset sort order when table changes
            if oldValue != newValue {
                sortOrder = []
            }
        }
    }

    @ViewBuilder
    private var resultsContent: some View {
        if let errorMessage = errorMessage {
            ContentUnavailableView {
                Label {
                    Text("Query Failed")
                        .font(.title3)
                } icon: {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.red)
                }
            } description: {
                Text(errorMessage)
                    .foregroundColor(.secondary)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        } else if results.isEmpty {
            // Show empty table with headers if column names are available
            if let columnNames = columnNames, !columnNames.isEmpty {
                // Empty table with overlay empty state message
                emptyTableWithHeaders(columnNames: columnNames)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .overlay(alignment: .center) {
                        EmptyQueryResultsView(hasExecutedQuery: hasExecutedQuery)
                    }
            } else {
                EmptyQueryResultsView(hasExecutedQuery: hasExecutedQuery)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
        } else {
            // Display results using SwiftUI Table
            resultsTable
        }
    }

    @ViewBuilder
    private var paginationBar: some View {
        HStack {
            Text("\(results.count) rows")
                .font(.system(.body, design: .monospaced))
                .foregroundStyle(.secondary)

            Spacer()

            HStack(spacing: 12) {
                Button {
                    onPreviousPage()
                } label: {
                    Image(systemName: "chevron.left")
                }
                .buttonStyle(.borderless)
                .disabled(!hasPreviousPage || isExecuting)

                Text("Page \(currentPage + 1)")
                    .font(.system(.body, design: .monospaced))
                    .foregroundStyle(.secondary)

                Button {
                    onNextPage()
                } label: {
                    Image(systemName: "chevron.right")
                }
                .buttonStyle(.borderless)
                .disabled(!hasNextPage || isExecuting)
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 4)
        .background(.bar)
        .overlay(alignment: .top) {
            Divider()
        }
    }

    @ViewBuilder
    private var resultsTable: some View {
        if let columnNames = columnNames {
            Table(sortedResults, selection: $selectedRowIDs, sortOrder: $sortOrder) {
                TableColumnForEach(columnNames, id: \.self) { columnName in
                    TableColumn(columnName, sortUsing: TableRowComparator(columnName: columnName)) { row in
                        Text(formatValue(row.values[columnName] ?? nil))
                            .font(.system(.body, design: .monospaced))
                            .textSelection(.enabled)
                    }
                    .width(min: Constants.ColumnWidth.tableColumnMin)
                }
            }
            .id(tableId)
            .onDeleteCommand {
                if !selectedRowIDs.isEmpty {
                    onDeleteKeyPressed?()
                }
            }
            .onKeyPress(.space) {
                if !selectedRowIDs.isEmpty {
                    onSpaceKeyPressed?()
                    return .handled
                }
                return .ignored
            }
        }
    }

    @ViewBuilder
    private func emptyTableWithHeaders(columnNames: [String]) -> some View {
        // Create a Table with just headers, no rows
        Table([] as [TableRow], selection: .constant(Set<TableRow.ID>())) {
            TableColumnForEach(columnNames, id: \.self) { columnName in
                TableColumn(columnName) { row in
                    Text(formatValue(row.values[columnName] ?? nil))
                        .font(.system(.body, design: .monospaced))
                }
                .width(min: Constants.ColumnWidth.tableColumnMin)
            }
        }
        .id(tableId)
    }

    private var filteredResults: [TableRow] {
        guard !searchText.isEmpty else { return results }
        let lowercasedSearch = searchText.lowercased()
        return results.filter { row in
            row.values.values.contains { value in
                guard let value = value else { return false }
                return value.lowercased().contains(lowercasedSearch)
            }
        }
    }

    private var sortedResults: [TableRow] {
        filteredResults.sorted(using: sortOrder)
    }

    private func formatValue(_ value: String?) -> String {
        guard let value = value else { return "NULL" }
        return value
    }
}
